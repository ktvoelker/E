
Grammar
=======

end := ';'

name := sep_list_1(simple_name, '.')

params := '(' sep_list(param, ',') ')'

param := simple_name (':' type)?

type_def :=
    'struct' name params? '{' struct_elems '}' end
  // Only one of the union_elems can have an initial value.
  | 'union' name params? '{' union_elems '}' end
  // The arguments are just for specifying the backing type of the enum or mask,
  // but we can give better error messages by accepting any valid argument list at
  // the syntactic level.
  | ('enum' | 'mask') arguments? name params? '{' enum_elems '}' end

struct_elems := sep_list_1(struct_elem, ',')

struct_elem := simple_name ':' type '=' expr

union_elems := sep_list_1(union_elem, ',')

union_elem := simple_name ':' type ('=' expr)?

enum_elem := simple_name ('=' expr)?

type :=
  // There are some special hard-wired names that can go here:
  // ptr (pointer, also used for arrays)
  // const (like ptr, but read-only)
  // tag (get tag type of union)
  // and all the primitive types
    name arguments?
  | params '=>' type

expr :=
    literal
  // There are some special hard-wired names that can go here:
  // length (get length of array)
  // tag (get tag value of union)
  // ref (increment reference count)
  // unref (decrement reference count)
  // const (safe cast from ptr to const)
  // cast (unsafe cast to any specified type)
  | expr arguments?
  // There are some special hard-wired unary operators:
  // * (dereference ptr or const)
  | unary_op expr
  // There are some special hard-wired binary operators:
  // && (short-circuit logical conjunction)
  // || (short-circuit logical disjunction)
  // == (structural equality over all types)
  // != (structural inequality over all types)
  // <, >, <=, >= (structural comparison over all types which don't contain pointers)
  // <=> (structural comparison, as above, but returning a 3-valued-enum result)
  | expr bin_op expr

arguments := '(' sep_list(expr, ',') ')'

literal :=
    primitive_literal
  | 'new' name arguments?
  | params ':' type '=>' fn_body

fn_body := expr | block

block := '{' stmt* '}'

stmt :=
    expr end
  | def
  // The initial "with" expression is a predicate function applied to each test
  // expression. By default, the identity function over Booleans is used.
  | ('with' expr)? 'if' expr block ('elif' expr block)* ('else' block)?
  | 'while' ('(' loop_var ')')? expr block ('next' block)?
  // The for-each loop expression must be of a type for which all the necessary
  // functions are defined to allow it to be used as an iterable thing.
  | 'for' '(' loop_var 'in' expr ')' block ('next' block)?
  | ('next' | 'done' | 'return') end
  | 'decide' arguments '{' option* '}'

option := '(' sep_list(expr | '_', ',') ')' '=>' (expr end | block)

loop_var := simple_name ':' type '=' expr

def := 'def' simple_name '=' (expr end | block)

ns :=
    file_ns
  | block_ns

file_ns := 'ns' simple_name end ns_elem* eof

block_ns := 'ns' simple_name '{' ns_elem* '}'

ns_elem :=
    block_ns
  | def_mod* def
  | import

def_mod :=
    'export'
  | 'global'

import := 'import' (sep_list(simple_name, ','))? 'from' name end

