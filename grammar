
Grammar
=======

epsilon :=

end := ';'

name := sep_list_1(simple_name, '.')

params := '(' sep_list(param, ',') ')' | epsilon

param := simple_name (':' type)?

type_def :=
    'struct' name params '{' struct_elems '}' end
  // Only one of the union_elems can have an initial value.
  | 'union' name params '{' union_elems '}' end
  // The arguments are just for specifying the backing type of the enum or mask,
  // but we can give better error messages by accepting any valid argument list at
  // the syntactic level.
  | ('enum' | 'mask') arguments name params '{' enum_elems '}' end

struct_elems := sep_list_1(struct_elem, ',')

struct_elem := simple_name ':' type '=' expr

union_elems := sep_list_1(union_elem, ',')

union_elem := simple_name ':' type ('=' expr)?

enum_elem := simple_name ('=' expr)?


// TODO

// type and value expressions (including array types)
  
  // Special expressions include:
  // getting the tag type (an implicit enum) and tag value (an implicit large-enough integral) of a union

// function definitions (with export option)

// namespace definitions and import declarations

// global and thread-local variable declarations (with export option)

